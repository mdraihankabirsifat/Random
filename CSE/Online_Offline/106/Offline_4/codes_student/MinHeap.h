#ifndef MINHEAP_H
#define MINHEAP_H
#include <iostream>
#include <fstream>
#include <stdexcept>
#include <climits>
using namespace std;
#define MAX_CAPACITY 1000 // Defines the maximum capacity of the heap

class MinHeap
{
private:
    int heap[MAX_CAPACITY]; // Array to store heap elements
    int size;               // Current number of elements in the heap

    /**
     * Sifts up the node at index i to maintain heap property.
     */
    void siftUp(int i)
    {
        /**Write your code here**/
        for (int j = i; j > 0; j = (j - 1) / 2)
        {
            if (heap[j] < heap[(j - 1) / 2])
            {
                swap(heap[j], heap[(j - 1) / 2]);
            }
            else
            {
                break;
            }
        }
    }

    /**
     * Sifts down the node at index i to maintain heap property.
     */
    void siftDown(int i)
    {
        /**Write your code here**/
        int left = 2 * i + 1, right = 2 * i + 2;
        int s = i;
        if (left < size && heap[s] > heap[left])
        {
            s = left;
        }
        if (right < size && heap[s] > heap[right])
        {
            s = right;
        }
        if (s != i)
        {
            swap(heap[s], heap[i]);
            siftDown(s);
        }
    }

public:
    // Constructor initializes an empty heap
    MinHeap() : size(0)
    {
    }

    /**
     * Inserts a new element x into the heap.
     */
    void insert(int x)
    {
        /**Write your code here**/
        if (size == MAX_CAPACITY)
        {
            throw runtime_error("Heap is full");
        }
        size++;
        heap[size - 1] = x;
        siftUp(size - 1);
    }

    /**
     * Removes and returns the minimum element from the heap.
     */
    int extractMin()
    {
        /**Write your code here**/
        if (size == 0)
        {
            throw runtime_error("Heap is Empty.");
        }
        int temp = heap[0];
        heap[0] = heap[size - 1];
        size--;
        siftDown(0);
        return temp;
    }

    /**
     * Returns the minimum element without removing it.
     */
    int findMin()
    {
        /**Write your code here**/
        if (size < 1)
        {
            throw runtime_error("Heap is Empty.");
        }
        return heap[0];
    }

    /**
     * Returns the number of elements in the heap.
     */
    int getSize()
    {
        /**Write your code here**/
        return size;
    }

    /**
     * Checks if the heap is empty.
     * Returns true if empty, false otherwise.
     */
    bool isEmpty()
    {
        /**Write your code here**/
        return size == 0;
    }

    /**
     * Decreases the value of the element at index i to newValue.
     */
    void decreaseKey(int i, int newValue)
    {
        /**Write your code here**/
        if (i < 0 || i >= size)
        {
            throw runtime_error("Invalid index.");
        }

        if (newValue > heap[i])
        {
            throw runtime_error("New value is greater than current value.");
        }
        heap[i] = newValue;
        siftUp(i);
    }

    /**
     * Deletes the element at index i.
     */
    void deleteKey(int i)
    {
        /**Write your code here**/
        if (i < 0 || i >= size)
        {
            throw runtime_error("Invalid index.");
        }
        if (i == size - 1)
        {
            size--;
            return;
        }
        heap[i] = heap[size - 1];
        size--;
        if (i > 0 && heap[i] < heap[(i - 1) / 2])
        {
            siftUp(i);
        }
        else
        {
            siftDown(i);
        }
    }

    /**
     * Prints the heap's content to the output file.
     * Format: "elem1 elem2 elem3 ..." (space-separated)
     */
    void printHeap(ofstream &outfile)
    {
        /**Write your code here**/
        for (int i = 0; i < size; i++)
        {
            outfile << heap[i];
            if (i != size - 1)
            {
                outfile << " ";
            }
        }
        outfile << endl;
    }

    /**
     * Checks whether the Min Heap property is preserved.
     * Returns true if valid, false otherwise.
     */
    bool isValidMinHeap()
    {
        /**Write your code here**/
        for (int i = 0; i < size; i++)
        {
            int left = 2 * i + 1;
            int right = 2 * i + 2;
            if (left < size && heap[i] > heap[left])
            {
                return false;
            }
            if (right < size && heap[i] > heap[right])
            {
                return false;
            }
        }
        return true;
    }

    /**
     * Builds a heap from an unsorted array using bottom-up heapify.
     */
    void heapify(int arr[], int n)
    {
        /**Write your code here**/
        if (n > MAX_CAPACITY)
        {
            throw runtime_error("Heap exceeds maximum capacity.");
        }
        size = n;
        for (int i = 0; i < n; i++)
        {
            heap[i] = arr[i];
        }
        for (int i = (n / 2) - 1; i >= 0; i--)
        {
            siftDown(i);
        }
    }

    /**
     * Returns all elements in sorted (ascending) order.
     * The original heap should remain UNCHANGED after this operation.
     */
    void heapSort(ofstream &outfile)
    {
        /**Write your code here**/
        int size2 = size;
        int heap2[MAX_CAPACITY];
        for (int i = 0; i < size; i++)
        {
            heap2[i] = heap[i];
        }
        for (int i = 0; i < size2; i++)
        {
            int m = extractMin();
            outfile << m;
            if (i != size2 - 1)
            {
                outfile << " ";
            }
        }
        outfile << endl;
        size = size2;
        for (int i = 0; i < size2; i++)
        {
            heap[i] = heap2[i];
        }
    }

    /**
     * Replaces the minimum element with a new value x in a single operation.
     * Returns the old minimum value.
     */
    int replaceMin(int x)
    {
        /**Write your code here**/
        if (size == 0)
        {
            throw runtime_error("Heap is empty.");
        }
        int temp = heap[0];
        heap[0] = x;
        siftDown(0);
        return temp;
    }
};
#endif // MINHEAP_H