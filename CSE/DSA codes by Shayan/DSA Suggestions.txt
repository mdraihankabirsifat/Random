Linked List
1. Reverse a linked list.
2. Detect a cycle in a linked list (Floyd’s Cycle Detection Algorithm).
3. Merge two sorted linked lists.
4. Remove the nth node from the end of a linked list.
5. Find the middle of a linked list.
6. Check if a linked list is a palindrome.
7. Rotate a linked list to the right by k places.
8. Flatten a multilevel doubly linked list.
9. Intersection point of two linked lists.
10. Clone a linked list with random pointers.

Stack
1. Implement a stack using arrays or linked lists.
2. Evaluate a postfix expression.
3. Convert infix to postfix expression.
4. Find the next greater element for each element in an array.
5. Find the stock span for each day.
6. Implement a MinStack to get the minimum element in O(1) time.
7. Check if a string of parentheses is valid or balanced.
8. Sort a stack using another stack (or recursion).
9. Largest rectangular area in a histogram.
10. Reverse a stack using recursion.

Queue
1. Implement a queue using arrays or linked lists.
2. Implement a circular queue.
3. Implement a deque (double-ended queue).
4. Reverse a queue using recursion.
5. Generate binary numbers from 1 to n using a queue.
6. Implement a stack using two queues.
7. Find the first non-repeating character in a stream of characters.
8. Implement a priority queue using a heap.
9. Sliding window maximum (maximum of all subarrays of size k).
10. Rotten Oranges problem (minimum time to rot all oranges).

Graph
1. Depth-First Search (DFS) traversal.
2. Breadth-First Search (BFS) traversal.
3. Detect a cycle in a graph (directed/undirected).
4. Shortest path in an unweighted graph using BFS.
5. Dijkstra's algorithm for single-source shortest paths.
6. Kruskal’s algorithm for minimum spanning tree.
7. Prim’s algorithm for minimum spanning tree.
8. Topological sort (Kahn’s Algorithm or DFS-based). 
9. Find strongly connected components (Kosaraju’s or Tarjan’s Algorithm).
10. Flood fill algorithm.

Heap
1. Implement a max heap/min heap from scratch.
2. Find the kth largest/smallest element in an array.
3. Merge k sorted arrays.
4. Find the median of a data stream.
5. Sort an array using heap sort.
6. Find the top k frequent elements in an array.
7. Rearrange characters in a string so that no two adjacent are the same.
8. Find the smallest range covering elements from k sorted lists.
9. Connect n ropes to minimize the cost.
10. Sliding window maximum using a max heap.

Binary Search Tree
1. Insert a node in a BST.
2. Delete a node in a BST.
3. Find the kth smallest element in a BST.
4. Check if a given tree is a BST.
5. Convert a BST to a doubly linked list.
6. Find the Lowest Common Ancestor (LCA) of two nodes in a BST.
7. Find the in-order successor and predecessor of a node in a BST.
8. Construct a BST from a sorted array.
9. Range sum of BST.
10. Find the closest value to a target in a BST.

Dynamic Programming (DP)
1. Fibonacci numbers (top-down and bottom-up approaches).<—
2. Longest Increasing Subsequence (LIS).<—
3. Longest Common Subsequence (LCS).
4. Knapsack problem (0/1 knapsack).
5. Coin change problem (minimum coins and total combinations).
6. Edit distance between two strings.
7. Maximum sum subarray (Kadane’s Algorithm).
8. Subset sum problem.
9. Matrix chain multiplication.
10. Unique paths in a grid (with obstacles).<—

Divide and Conquer
1. Binary search in a sorted array.
2. Merge sort.
3. Quick sort.
4. Find the maximum and minimum in an array using a divide-and-conquer approach.
5. Find the closest pair of points in a 2D plane.
6. Count inversions in an array.
7. Maximum subarray sum (divide and conquer version of Kadane’s algorithm).
8. Median of two sorted arrays.
9. Exponentiation by squaring (power function).
10. Skyline problem (merging overlapping buildings).